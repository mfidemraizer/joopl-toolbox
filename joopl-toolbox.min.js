/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Toolbox
 https://github.com/mfidemraizer/joopl-toolbox

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

(function() {
    "use strict";

	$namespace.register("joopl.collections", function() {
	    this.declareClass("InvalidOperationException", {
	        imports: $global.joopl.Exception,
	        ctor: function(args) {
              if(args || args.message) {
                args.message = "Operation could not be completed because an invalid state";
              }

	            this.base.ctor(args);
	        }
		});
	});
})();
/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Toolbox
 https://github.com/mfidemraizer/joopl-toolbox

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

(function() {
    "use strict";

    /**
		@module System
		@namespace joopl
    */
	$namespace.register("joopl", function() {

		/**
			Represents a set of object conversion operations

			@class Convert
			@final
		*/
	    this.declareClass("Convert", {
	        members: {
	        	/**
					Converts a primitive value to a boxed object

					@method toObject
					@param {number|string|boolean} value The whole value to convert to a boxed object
					@param {boolean} throwOnNotSupported If this parameter is given with a `true` boolean value, if the given value argument is not supported, throws an `ArgumentException`
					@return {Number|String|Boolean} The boxed value as object
	        	*/
	            toObject: function(value, throwOnNotSupported) {
	                switch(typeof value) {
	                    case "number":
	                        return new Number(value);
	                    case "string":
	                        return new String(value);
	                    case "boolean":
	                        return new Boolean(value);
	                    default: 
	                        if(throwOnNotSupported) {
	                            throw new this.ArgumentException({
	                                argName: "value",
	                                reason: "Primitive type not supported"
	                            });
	                        } else {
	                            return null;
	                        }
	                }
	            } 
	        }
	    });
	});
})();
/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Toolbox
 https://github.com/mfidemraizer/joopl-toolbox

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

(function () {
    "use strict";

    /**
    	@namespace joopl.collections
	*/
	$namespace.register("joopl.collections", function() {

		/**
			Represents the base class for an iterator to enumerate some sequence.

			@class Enumerator
		*/
		this.declareClass("Enumerator", {
			members: {
				/**
					In derived classes, moves the sequence to the next element and returns it.

					@method moveNext
					@returns {object} The next item.
				*/
				moveNext: function() {
					throw new $global.joopl.NotImplementedException({ memberName: "Enumerator.moveNext" });
				},

				/**
					In derived classes, determines if the sequence has a next item.

					@property hasNext
					@type boolean
					@readonly
				*/
				get hasNext() {
					throw new $global.joopl.NotImplementedException({ memberName: "Enumerator.hasNext" });
				}
			}
		});
	});
})();
/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Toolbox
 https://github.com/mfidemraizer/joopl-toolbox

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
(function () {
    "use strict";

    /**
		@namespace joopl.collections
    */

	$namespace.register("joopl.collections", function() {
		var collections = this;

		/** 
			Represents an abstract object that is able of being enumerated using supported iterators.
			
			@class Enumerable
		*/
		this.declareClass("Enumerable", {
			members: {
				/**
					Inherited classes return an instance of enumerable-specific enumerator.

					@property enumerator
					@type joopl.collections.Enumerator
					@readonly
				*/
				get enumerator() {
					throw new Error(new $global.joopl.NotImplementedException({ memberName: "enumerator" }));
				},

				/**
					Inherited classes return an enumerable holding same items in the sequence as current
					one but in the reversed order.

					@method reverse
					@returns joopl.collections.Enumerable
				*/
				reverse: function() {
					throw new Error(new $global.joopl.NotImplementedException({ memberName: "Enumerable.reverse" }));
				},

				/**
					Executes an action defined by a predicate function for each item in the enumerable sequence.

					@method forEach
					@param {Function} predicateFunc An action to perform for each item in the enumerable sequence
					@returns void
					@example
						enumerable.forEach(function(item) {
							// Do stuff here
						});
				*/
				forEach: function(predicateFunc) {
					var enumerator = this._.derived.enumerator;
					var end = false;

					while(!end && enumerator.hasNext) {
						var item = enumerator.moveNext();

						end = item === undefined;

						if(!end) {
							predicateFunc(item);
						}
					}

					return this;
				},

				/**
					Retrieves an unique item in the sequence. If there are no elements, returns `null`,

					Optionally, it can take a predicate function as argument returning a boolean in order to
					specify how to determine the singleness of the searched item.

					@method singleOrNull 
					@returns object
					@param {Function} predicateFunc A predicate function which provides a boolean condition that must satisfy the single item
					@example
						var result = enumerable.singleOrNull(function(item) {
							return item == "hello world";
						});

						var result2 = enumerable.singleOrNull();
				*/
				singleOrNull: function(predicateFunc) {
				    var result = this.where(predicateFunc);

				    if (result.count() > 1) {
				        throw new Error(new $global.joopl.InvalidOperationException({
                            message: "Sequence contains more than one element"
				        }));
				    }

				    return result.firstOrNull();
				},

				/**
					Retrieves an unique item in the sequence. If there are no elements, throws an `InvalidOperationException`,

					Optionally, it can take a predicate function as argument returning a boolean in order to
					specify how to determine the singleness of the searched item.

					@method singleOrNull 
					@returns object
					@param {Function} predicateFunc A predicate function which provides a boolean condition that must satisfy the single item
					@example
						var result = enumerable.single(function(item) {
							return item == "hello world";
						});

						var result = enumerable.single();
				*/
				single: function(predicateFunc) {
				    var result = this.singleOrNull(predicateFunc);

				    if (result === null) {
				        throw new Error(new $global.joopl.InvalidOperationException({
				            message: "Sequence contains no elements"
				        }));
				    }

				    return result;
				},

				/**
					Retrieves first item in the sequence. If there are no elements, returns null,

					Optionally, it can take a predicate function as argument returning a boolean in order to
					specify what criteria should conform first item in the sequence.

					@method firstOrNull 
					@returns object
					@param {Function} predicateFunc A predicate function which provides a boolean condition that must satisfy the single item
					@example
						var result = enumerable.firstOrNull(function(item) {
							return item == "hello world";
						});

						var result = enumerable.firstOrNull();
				*/
				firstOrNull: function (predicateFunc) {
				    var enumerator = this._.derived.enumerator;
				    var found = false;
				    var foundItem = null;

				    if (predicateFunc) {
				        while (!found && enumerator.hasNext) {
				            var item = enumerator.moveNext();

				            found = predicateFunc(item);
				        }

				        if (found) {
				            foundItem = item;
				            found = true;
				        }
				    } else {
				        foundItem = enumerator.moveNext();
				        found = foundItem != undefined;
				    }

				    if (found) {
				        return foundItem;
				    } else {
				        return null;
				    }
				},

				/**
					Retrieves first item in the sequence. If there are no elements, throws an `InvalidOperationException`,

					Optionally, it can take a predicate function as argument returning a boolean in order to
					specify what criteria should conform first item in the sequence.

					@method first
					@returns object
					@param {Function} predicateFunc A predicate function which provides a boolean condition that must satisfy the single item
					@example
						var result = enumerable.first(function(item) {
							return item == "hello world";
						});

						var result = enumerable.first();
				*/
				first: function (predicateFunc) {
				    var foundItem = this.firstOrNull(predicateFunc);

					if (foundItem !== null) {
					    return foundItem;
					} else {
					    throw new Error(new $global.joopl.InvalidOperationException({ message: "Sequence contains no elements" }));
					}
				},

				/**
					Retrieves last item in the sequence. If there are no elements, returns null,

					Optionally, it can take a predicate function as argument returning a boolean in order to
					specify what criteria should conform last item in the sequence.

					@method last 
					@returns object
					@param {Function} predicateFunc A predicate function which provides a boolean condition that must satisfy the last item search
					@example
						var result = enumerable.lastOrNull(function(item) {
							return item == "hello world";
						});

						var result = enumerable.lastOrNull();
				*/
				lastOrNull: function (predicateFunc) {
				    var reversed = this._.derived.reverse();

				    return reversed.firstOrNull(predicateFunc);
				},

				/**
					Retrieves last item in the sequence. If there are no elements, throws an `InvalidOperationException`,

					Optionally, it can take a predicate function as argument returning a boolean in order to
					specify what criteria should conform last item in the sequence.

					@method lastOrNull
					@returns object
					@param {Function} predicateFunc A predicate function which provides a boolean condition that must satisfy the last item search
					@example
						var result = enumerable.last(function(item) {
							return item == "hello world";
						});

						var result = enumerable.last();
				*/
				last: function(predicateFunc) {
					var reversed = this._.derived.reverse();

					return reversed.first(predicateFunc);
				},

				/**
					Counts items in the sequence.

					Optionally, it can take a predicate function as argument returning a boolean in order to specify what criteria should conform 
					each item to be counted in the sequence.

					@method count
					@returns number
					@param {Function} predicateFunc A predicate function which provides a boolean condition that must satisfy the last item search
					@example
						var result = enumerable.count(function(item) {
							return item == "hello world";
						});

						var result = enumerable.count();

				*/
				count: function(predicateFunc) {
					var count = 0;

					if(predicateFunc instanceof Function) {
						this.forEach(function(item) {
							if(predicateFunc(item)) {
								count++;
							}
						});
					} else {
						this.forEach(function(item) {
							count++;
						});
					}

					return count;
				},

				/**
					Returns items that conform a boolean condition.

					@method where
					@return joopl.collections.Enumerable An `Enumerable` containing found items
					@param {Function} predicateFunc A predicate function which provides a boolean condition that must satisfy an item
					@example
						var result = enumerable.where(function(item) {
							return item == "hello world";
						});

				*/
				where: function(predicateFunc) {
					if(!(predicateFunc instanceof Function)) {
						throw new Error(new $global.joopl.ArgumentException({
							argName: "predicateFunc",
							reason: "Given predicate function is not a function"
						}));
					}

					var result = new $global.joopl.collections.List();

					this.forEach(function(item) {
						if(predicateFunc(item)) {
							result.add(item);
						}
					});

					return result;
				},

				/**
					Projects each item in the sequence. Item projection is defined by a predicate function.

					@method select
					@returns joopl.collections.Enumerable
					@param {Function} predicateFunc A predicate function which provides how to project each item
					@example
						var result = enumerable.select(function(item) {
							return { text: item };
						});

				*/
				select: function(predicateFunc) {
					if(!(predicateFunc instanceof Function)) {
						throw new Error(new $global.joopl.ArgumentException({
							argName: "predicateFunc",
							reason: "Given predicate function is not a function"
						}));
					}

					var result = new $global.joopl.collections.List();

					this.forEach(function(item) {
						result.add(predicateFunc(item));
					});

					return result;
				},

				skip: function(numberOfItems) {
					throw new $global.joopl.NotImplementedException({ memberName: "Enumerable.skip" });
				},


				/**
					Returns a queryable object for the sequence.

					@method asQueryable
					@returns joopl.collections.Enumerable
					@param {Function} predicateFunc A predicate function which provides how to project each item
					@example
						var queryable = enumerable.asQueryable();

				*/
				asQueryable: function() {
					return new collections.Queryable({ enumerable: this });
				},

				/**
					Inherited classes returns items of this sequence as a standard JavaScript array object.

					@method toArray
					@returns Array
					@example
						var result = enumerable.toArray();

				*/
				toArray: function() {
					throw new $global.joopl.NotImplementedException({ memberName: "Enumerable.toArray" });
				},

				/**
					Adds items in the enumerable to a `List` and returns it.

					@method toList
					@return {joopl.collections.List} A `List` containing current enumerable's items.
				*/
				toList: function() {
					var list = new collections.List();
					list.addRange(this);

					return list;
				}
			}
		});
	});
})();
/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Toolbox
 https://github.com/mfidemraizer/joopl-toolbox

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

(function() {
    "use strict";

    /**
		@namespace joopl.collections
    */

	$namespace.register("joopl.collections", function () {
	    var collections = this;

	    /**
			Represents the base class to implement indexes for `IndexableList`.

			@class Index
			@abstract
			@constructor
			@param {IndexedList} source The source `IndexedList`
			@param {string} property The name of the property to be indexed
			@param {boolean} (optional) unique A boolean giving `true` if it is an unique index or not.
			@extends joopl.collections.Enumerable
	    */
		this.declareClass("Index", {
			inherits: collections.Enumerable,
			ctor: function (args) {
				if(typeof args != "object") {
					if(typeof args != "object") {
						throw new $global.joopl.ArgumentException({
							argName: "args",
							reason: "The constructor requires parameters"
						});
					}
				}

				if(typeof args.source != "object") {
					throw new $global.joopl.ArgumentException({
						argName: "source",
						reason: "Indexes must be associated to a source"
					});
				}

				if(typeof args.property != "string") {
					throw new $global.joopl.ArgumentException({
						argName: "property",
						reason: "Indexes require which property must be indexed"
					});
				}

				this._.source = args.source;
				this._.property = args.property;
				this._.unique = typeof args.unique == "boolean" ? args.unique : false;
			},
			members: {
				/**
					Gets a reference to the associated `IndexedList`

					@property source
					@type IndexedList
					@readOnly
				*/
				get source() {
					return this._.source;
				},

				/**
					Gets a boolean which determines if it is an unique index or not

					@property unique
					@type boolean
					@readOnly
				*/
				get unique() {
					return this._.unique;
				},

				/**
					Gets the name of indexed property

					@property property
					@type string
					@readOnly
				*/
				get property() {
					return this._.property;
				},

				/**
					In derived classes, this method is called when some data changes and index should be recalculated or, at least, processed.

					@method onDataChange
					@param {object} args Optional arguments for the data change handling
					@return {void}
					@protected
				*/
				onDataChange: function(args) {
				}
			}
		});
	});
})();
/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Toolbox
 https://github.com/mfidemraizer/joopl-toolbox

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
(function() {
    "use strict";

    /**
		@namespace joopl.collections
    */
	$namespace.register("joopl.collections", function () {
	    var collections = this;

	    /**
			Represents an indexed collection of objects. Objects are indexed by configured indexes using `addIndex` method.

			@class IndexedList
			@extends joopl.collections.ObservableList
			@final 
	    */
		this.declareClass("IndexedList", {
			inherits: collections.ObservableList,
			ctor: function (args) {
			    this.base.ctor(args);

			    this._.indexes = new collections.List();
			    this.changed.addEventListener(this.list_changed.bind(this));
			},
			members: {
				get indexes() {
					return this._.indexes;
				},

				add: function(item) {
					this.base.add(item);
				},

				/**
					Adds and configures a new index to this `IndexedList`.

					@method addIndex
					@param {Index} index An implementation of `Index`.
				*/
				addIndex: function(index) {
					if(index.isTypeOf(collections.Index)) {
						this.indexes.add(index);
					} else {
						throw new $global.joopl.ArgumentException({
							argName: "index",
							reason: "Given object is not an index"
						});
					}
				},

				decideIndexOrSequence: function(predicateFuncOrIndexedSearch, isIndexedFunc, isNonIndexedFunc) {
					if(predicateFuncOrIndexedSearch instanceof Function) {
						return isNonIndexedFunc();
					} else {
						var propertySelector = {};
						var predicateFunc = null;

						var parameters = Object.keys(predicateFuncOrIndexedSearch);

						if(typeof predicateFuncOrIndexedSearch[parameters[0]] != "function") {
							propertySelector[parameters[0]] = predicateFuncOrIndexedSearch[parameters[0]];
							predicateFunc = predicateFuncOrIndexedSearch[parameters[1]];
						} else if (typeof predicateFuncOrIndexedSearch[parameters[1]] == "function") {
							propertySelector = predicateFuncOrIndexedSearch[parameters[1]];
							predicateFunc = predicateFuncOrIndexedSearch[parameters[0]];
						} else {
							throw new Error(new $global.joopl.ArgumentException({
								argName: "predicateFuncOrIndexedSearch",
								reason: "The indexed search requires a property selector"
							}));
						}

						var propertyName = parameters[0];
						var index = this._.indexes.single(function(index) { return index.property == propertyName; });

						var result = new collections.List();

						var tempPropertyValue = null;

						for(var selectorIndex in propertySelector[index.property]) {
							tempPropertyValue = {};
							tempPropertyValue[index.property] = propertySelector[index.property][selectorIndex];

							result.addRange(isIndexedFunc(index, tempPropertyValue, predicateFunc));
						}

						return result;
					}
				},

				/**
					Returns items that conform a boolean condition.

					In opposite to regular `Enumerable.where(...)`, `IndexedList.where(...)` supports an indexed search 
					argument which specifies a property and a value to search for.

					@method where
					@return joopl.collections.Enumerable An `Enumerable` containing found items
					@example
		            var result = list.where({ 
		                text: ["hel", "w", "!" ], // <-- This is the property selector: search an item with this possible values
		                predicate: function(item) { 
		                	// "this" keyword will be one of possible "text" property values
		                	// so this condition says "I want an item if its "text" property is one of given possible values"
		                    return item.text.indexOf(this) == 0 || item.text == "halo"; 
		                } 
		            });
				*/
				where: function(predicateFuncOrIndexedSearch) {
					var that = this;

					return this.decideIndexOrSequence(
						predicateFuncOrIndexedSearch,
						function(index, propertySelector, predicateFunc) {
							return index.where(propertySelector, predicateFunc);
						},
						function() {
							return that.base.where(predicateFuncOrIndexedSearch);
						}
					);
				},

			    list_changed: function(args) {
			    	args.source._.indexes.forEach(function(index) {
			    		index.onDataChange(args);
			    	});
			    }
			}
		});
	});
})();
/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Toolbox
 https://github.com/mfidemraizer/joopl-toolbox

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
(function(undefined) {
    "use strict";

    /**
		@namespace joopl.collections
    */

	$namespace.register("joopl.collections", function() {
		var collections = this;

		/**
			Represents an ordered collection of objects

			@class List
			@extends joopl.collections.Enumerable
			@param {number} capacity (optional) Initializes the list with a predefined maximum capacity and allocates memory to enforce read and write operations
			@param {Array} itemArray (optional) Initializes the list with items from an existing array.
			@constructor
			@example
				new this.List(); // Default constructor
				new this.List({ capacity: 5 }); // Specifies list's capacity
				new this.List({ itemArray: ["hello", "world"]}); // Gives default items to the list
				new this.List({ capacity: 5, itemArray: ["hello", "world"] }); // Both gives default items and list's capacity
		*/
		this.declareClass("List", {
			inherits: this.Enumerable,
			ctor: function(args) {
				this._.capacity = args ? (typeof args.capacity == "number" ? args.capacity : 0) : 0;
				this._.itemArray = args ? (args.itemArray instanceof Array ? args.itemArray : []) : [];
				this._.capacityCursor = 0;

				if(this.capacity) {
					this.itemArray[this.capacity - 1] = undefined;
				}
			},
			members: {
				get enumerator() {
					return new collections.ListEnumerator({ itemArray: this._.itemArray });
				},

				/**
					Gets list's capacity 
					
					@property capacity
					@type number
					@readOnly
				*/
				get capacity() {
					return this._.capacity;
				},

				/**
					Gets underlying item array which represents in-memory list's storage

					@property itemArray
					@private
					@type Array
					@readOnly
				*/
				get itemArray() {
					return this._.itemArray;
				},


				/**
					Gets underlying item array cursor (SYSTEM USE ONLY)

					@property capacityCursor
					@private
					@type number
					@readOnly
				*/
				get capacityCursor() {
					return this._.capacityCursor;
				},

				/**
					Increases capacity cursor (SYSTEM USE ONLY)

					@method increaseCapacityCursor
					@private
				*/
				increaseCapacityCursor: function() {
					this._.capacityCursor++;
				},

				/**
					Increases capacity cursor (SYSTEM USE ONLY)

					@method avoidOverCapacityFunc
					@private
				*/
				avoidOverCapacityFunc: function(item) {
					return item !== undefined;
				},

				reverse: function(predicateFunc) {
					var reversed = this._.itemArray.slice().reverse();

					var reversedList = new collections.List();

					for(var index = 0; index < reversed.length; index++) {
						if(reversed[index] !== undefined) {
							reversedList.add(reversed[index]);
						}
					}

					return reversedList;
				},

				count: function(predicateFunc) {
					var that = this;

					if(predicateFunc instanceof Function) {
						return this.base.count(function(item) {
							return that.avoidOverCapacityFunc(item) && predicateFunc(item);
						});
					} else {
						if(this.capacity == 0) {
							return this.itemArray.length;
						} else {
							return this.base.count(that.avoidOverCapacityFunc);
						}
					}
				},

				/**
					Gets an item at the given index in the list

					@method itemAt
					@param {number} index An index in the list
					@return {object} The obtained item in the given index
				*/
				itemAt: function(index) {
					return this._.itemArray[index];
				},

				/**
					Finds the numeric index of a given item in the list.

					@method indexOf
					@param {object} item The whole item to search for its index
					@return {number} Returns the found index for the given item. If it is not found, returns -1
				*/
				indexOf: function(item) {
					var index = -1;
					var found = false;

					var enumerator = this.enumerator;

					do {
						index++;

						found = enumerator.moveNext() == item;
					}
					while(!found && enumerator.hasNext);

					if(found) {
						return index;
					} else {
						return -1;
					}
				},

				/**
					Adds an item to the list

					@method add
					@param {object} item The whole item to add
				*/
				add: function(item) {
					if(item === undefined) {
						throw new $global.joopl.ArgumentException({ memberName: "item", reason: "Undefined values are not supported" });
					}

					if(this.capacity == 0) {
						this.itemArray.push(item);
					} else if(this.capacity <= this.itemArray.length) {
						this.itemArray[this.capacityCursor] = item;
						this.increaseCapacityCursor();
					} else {
						throw new $global.joopl.ArgumentException({
							argName: "item",
							reason: "List capacity exceeded"
						});
					}
				},

				/**
					Adds items in an Enumerable to current list

					@method addRange
					@param {Enumerable} enumerable The Enumerable to copy items from
				*/
				addRange: function(enumerable) {
					enumerable.forEach((function(item) {
						this._.derived.add(item);
					}).bind(this));
				},

				/**
					Inserts an item at the specified index

					@method insertAt
					@param {number} index The index in the list where the item will be inserted
					@param {object} item The item to insert
				*/
				insertAt: function(index, item) {
					if(index >= this.count()) {
						throw new $global.joopl.ArgumentException({ memberName: "index", reason: "Index out of range" });
					}

					if(item === undefined) {
						throw new $global.joopl.ArgumentException({ memberName: "item", reason: "Undefined values are not supported" });
					}

					this.itemArray.splice(index, 0, item);
				},

				/**
					Replaces an item at the specified index

					@method replaceAt
					@param {number} index The index in the list where the item will be replaced
					@param {object} item The item to use as replacement to the existing one at the specified index
				*/
				replaceAt: function(index, item) {
					if(index >= this.count()) {
						throw new $global.joopl.ArgumentException({ memberName: "index", reason: "Index out of range" });
					}

					if(item === undefined) {
						throw new $global.joopl.ArgumentException({ memberName: "item", reason: "Undefined values are not supported" });
					}

					this.itemArray[index] = item;
				},

				/**
					Removes the specified item from the list

					@method remove
					@param {object} item The item to remove from the list
				*/
				remove: function(item) {
					this.removeAt(this.indexOf(item));
				},

				/**
					Removes an item in the specified index

					@method removeAt
					@param {number} index The index of the item to be removed
				*/
				removeAt: function(index) {
					if(index >= this.count()) {
						throw new $global.joopl.ArgumentException({ memberName: "index", reason: "Index out of range" });
					}

					this.itemArray.splice(index, 1);
				},

				skip: function(numberOfItems) {
					if(numberOfItems > this.count()) {
						throw new $global.joopl.ArgumentException({ memberName: "numberOfItems", reason: "Out of range" });
					}

					var itemArray = this.toArray();

					return new collections.List({ itemArray: itemArray.splice(numberOfItems) });
				}, 

				toArray: function() {
					var result = this.where(function(item) {
						return item !== undefined;
					});

					var arr = [];
					arr[result.itemArray.length - 1] = undefined;

					var index = -1;

					result.forEach(function(item) {
						arr[++index] = item;
					});

					return arr;
				},

				toString: function() {
					var textArray = [];

					for(var index in this.itemArray) {
						if(this.itemArray[index] !== undefined) {
							textArray.push(this.itemArray[index].toString());
						}
					}

					return textArray.join(", ");
				}
			}
		});
	});
})(undefined);
/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Toolbox
 https://github.com/mfidemraizer/joopl-toolbox

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
(function() {
    "use strict";

    /**
		@namespace joopl.collections
    */

	$namespace.register("joopl.collections", function() {

		/**
			Represents a List-based enumerator implementation

			@class ListEnumerator
			@constructor
			@param {Array} itemArray The underlying List's array
			@extends Enumerator
		*/
		this.declareClass("ListEnumerator", {
			inherits: this.Enumerator,
			ctor: function(args) {
				this._.itemArray = args.itemArray;
				this._.index = -1;
			},
			members: {
				/**
					Gets the underlying List's item array

					@readOnly
					@private
					@property itemArray
					@type Array
				*/
				get itemArray() {
					return this._.itemArray;
				},

				moveNext: function() {
					return this.itemArray[++this._.index];
				},

				get hasNext() {
					return this._.index + 1 < this.itemArray.length;
				}
			}
		});
	});
})();
/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Toolbox
 https://github.com/mfidemraizer/joopl-toolbox

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
(function() {
    "use strict";

  /**
      @namespace joopl.collections
  */
	$namespace.register("joopl.collections", function() {

      /**
        Represents an enumeration of available observable changes produced by a collection of objects

        @class ObservableChange
        @final
      */
	    this.declareEnum("ObservableChange", {
          /**
            Defines that some item has been added to the collection

            @property added
            @readOnly
            @type number
          */
	        added: 1,

          /**
            Defines that some item has been replaced in the collection

            @property replaced
            @readOnly
            @type number
          */
	        replaced: 2,

          /**
            Defines that some item has been removed from the collection

            @property removed
            @readOnly
            @type number
          */
	        removed: 3
	    });
	});
})();
/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Toolbox
 https://github.com/mfidemraizer/joopl-toolbox

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
(function() {
    "use strict";

    /**
		@namespace joopl.collections
    */

	$namespace.register("joopl.collections", function () {
	    var collections = this;

	    /**
			Represents a list of objects that can be observed for its changes:

			- When an item is *added*
			- When an item is *replaced*
			- When an item is *removed*

			@class ObservableList
			@extends joopl.collections.List
			@final
	    */
		this.declareClass("ObservableList", {
			inherits: this.List,
			ctor: function (args) {
			    this.base.ctor(args);
			},
			members: {
				/**
					Occurs when some item changes

					@event changed 
					@param {object} source The `ObservableList` instance which fires the event
					@param {joopl.collections.ObservableChange} changeKind The observable change kind (added, replaced and removed `ObservableChange` enumeration values`
					@param {object} item The affected item by the whole change
				*/
			    events: ["changed"],

			    add: function (item) {
			        this.base.add(item);
			        this.changed.raise({ args: { source: this, changeKind: collections.ObservableChange.added, item: item } });
				},

				insertAt: function (index, item) {
				    this.base.insertAt(index, item);
				    this.changed.raise({ args: { source: this, changeKind: collections.ObservableChange.added, item: item } });
				},

				replaceAt: function (index, item) {
				    this.base.replaceAt(index, item);
				    this.changed.raise({ args: { source: this, changeKind: collections.ObservableChange.replaced, oldItem: this.getItemAt(index), item: item } });
				},

				remove: function (item) {
				    this.base.remove(item);
				    this.changed.raise({ args: { source: this, changeKind: collections.ObservableChange.removed, item: item } });
				},

				removeAt: function (index) {
				    this.base.removeAt(index);
				    this.changed.raise({ args: { source: this, changeKind: collections.ObservableChange.removed, item: this.getItemAt(index) } });
				}
			}
		});
	});
})();
/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Toolbox
 https://github.com/mfidemraizer/joopl-toolbox

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
(function() {
    "use strict";

    /**
		@namespace joopl.collections
    */

	$namespace.register("joopl.collections", function() {
		var collections = this;

		/**
			Represents an index which orders items by a string property in partitions based on their initial letters.

			@class OrderedStringIndex
			@final
		*/
		this.declareClass("OrderedStringIndex", {
			inherits: collections.Index,
			ctor: function(args) {
				this.base.ctor(args);

				this._.partitions = new collections.List();
				this._.vocalPartitionRegEx = new RegExp("^(a|e|i|o|u|aa|ae|ai|ao|au|ea|ee|ei|eo|eu|ia|ie|io|iu|oa|oe|oi|oo|ou|ua|ue|ui|uo|uu)", "i");
				this._.consonantPartitionRegEx = new RegExp("^(b|c|Ã§|d|f|g|h|j|k|l|m|n|p|q|r|s|t|v|w|x|y|z)", "i");
				this._.numericAndSymbol = new RegExp("^[A-Za-z]", "i")

				this.initialize();
			},

			members: {
				get enumerator() {
					return this.source.enumerator;
				},

				/**
					Gets the regular expression to determine which partition to choose if the word starts with vocals

					@property vocalPartitionRegEx
					@type RegExp
					@readOnly
					@private
				*/
				get vocalPartitionRegEx() { 
					return this._.vocalPartitionRegEx;
				},

				/**
					Gets the regular expression to determine which partition to choose if the word starts with consonants

					@property consonantPartitionRegEx
					@type RegExp
					@readOnly
					@private
				*/
				get consonantPartitionRegEx() {
					return this._.consonantPartitionRegEx;
				},

				/**
					Gets the list of partitions

					@property partitions
					@type joopl.collections.List
					@readOnly
					@private
				*/
				get partitions() {
					return this._.partitions;
				},

				/**
					Initializes the index

					@method initialize
					@private
				*/
				initialize: function() {
					var abc = "abcdefghijklmnopqrstuvwxyz";
					var vocals = "aeiou";
					var letter = null;
					var vocal = null;

					this.partitions.add({ id: "other", store: new collections.List() });

					for(var letterIndex in abc) {
						letter = abc[letterIndex];

						if(vocals.indexOf(letter) == 0) {
							this.partitions.add({ id: letter, store: new collections.List() });
							
							for(var vocalIndex in vocals) {
								vocal = vocals[vocalIndex];

								this.partitions.add({ id: letter + vocal, store: new collections.List() });
							}
						} else {
							this.partitions.add({ id: letter, store: new collections.List() });
						}
					}
				},

				/**
					Finds the partition where some item is stored or it should be stored in

					@method findProperty
					@param {object} item The item whose value will be used to find the whole partition
					@private
				*/
				findPartition: function(item) {
					var partitionId = null;

					var isVocal = this.vocalPartitionRegEx.test(item);

					if(isVocal) {
						if(this.vocalPartitionRegEx.test(item.toLowerCase())) {
							if(item.length > 1 && this.vocalPartitionRegEx.test(item.substring(1, 1).toLowerCase())) {
								partitionId = item.substring(0, 2);
							} else {
								partitionId = item[0];
							}

						} else {
							partitionId = item[0];
						}
					} else if(this.consonantPartitionRegEx.test(item[0].toLowerCase())) {
						partitionId = item[0];
					} else {
						partitionId = "other";
					}

					partitionId = partitionId.toLowerCase();

					return this.partitions.singleOrNull(function(item) {
						return item.id == partitionId 
					});
				},

				onDataChange: function(args) {
					switch(args.changeKind) {
						case collections.ObservableChange.added:
							this.onAdded({ item: args.item });
							break;

						case collections.ObservableChange.replaced:
							this.onReplaced({ item: args.item });
							break;

						case collections.ObservableChange.removed:
							this.onRemoved({ item: args.item });
							break;
					}
				},

				onAdded: function(args) {
					var propertyName = this.property;
					var searchValue = args.item[propertyName];
					var propertySelectorFunc = this.propertySelectorFunc;
					var partition = this.findPartition(searchValue);

					if(this.unique) {
						if(partition.store.count(function(storeItem) { return storeItem[propertyName] === searchValue; }) == 0) {
							partition.store.add(args.item);
						} else {
							throw new Error(new $global.joopl.ArgumentException({
								argName: "item",
								reason: "Unique index violation"
							}));
						}
					} else {
						partition.store.add(args.item);
					}
				},

				onReplaced: function(args) {
					var partition = this.findPartition(args.item);

					if(this.unique) {
						if(partition.store.count(function(item) { return item.value == args.item }) > 0) {
							throw new Error(new $global.joopl.ArgumentException({
								argName: "item",
								reason: "Unique index violation"
							}));
						}
					}

					var replacedItemIndex = partition.store.indexOf(args.oldItem);
					partition.store.replaceAt(replacedItemIndex, args.item);
				},

				onRemoved: function(args) {
					var partition = this.findPartition(args.item);

					var removedItemIndex = partition.store.indexOf(args.item);
					partition.store.removeAt(replacedItemIndex);
				},

				forEach: function(predicateFunc) {
					throw new Error(new $global.joopl.NotImplementedException({ memberName: "OrderedStringIndex.forEach" }));
				},

				reverse: function() {
					throw new Error(new $global.joopl.NotImplementedException({ memberName: "OrderedStringIndex.reverse" }));
				},

				single: function(propertySelector, predicateFunc) {
					var partition = this.findPartition(propertySelector[this.property]);

					return partition.store.single(predicateFunc.bind(propertySelector[this.property]));
				},

				singleOrNull: function(propertySelector, predicateFunc) {
					var partition = this.findPartition(propertySelector[this.property]);

					return partition.store.singleOrNull(predicateFunc.bind(propertySelector[this.property]));
				},

				first: function(propertySelector, predicateFunc) {
					var partition = this.findPartition(propertySelector[this.property]);

					return partition.store.first(predicateFunc.bind(propertySelector[this.property]));
				},

				firstOrNull: function(propertySelector, predicateFunc) {
					var partition = this.findPartition(propertySelector[this.property]);

					return partition.store.firstOrNull(predicateFunc.bind(propertySelector[this.property]));
				},

				last: function(propertySelector, predicateFunc) {
					var partition = this.findPartition(propertySelector[this.property]);

					return partition.store.last(predicateFunc.bind(propertySelector[this.property]));
				},

				lastOrNull: function (propertySelector, predicateFunc) {
					var partition = this.findPartition(propertySelector[this.property]);

					return partition.store.lastOrNull(predicateFunc.bind(propertySelector[this.property]));
				},

				count: function(propertySelector, predicateFunc) {
					var partition = this.findPartition(propertySelector[this.property]);

					return partition.store.count(predicateFunc.bind(propertySelector[this.property]));
				},

				where: function(propertySelector, predicateFunc) {		
					var partition = this.findPartition(propertySelector[this.property]);

					return partition.store.where(predicateFunc.bind(propertySelector[this.property]));
				}
			}
		});
	});
})();
(function() {
    "use strict";

    /**
		@namespace joopl.collections
    */

	$namespace.register("joopl.collections", function() {
		var collections = this;

		/**
			Represents an enumerable which defers certain operations until the enumerable is iterated.

			@class Queryable
			@extends joopl.collections.Enumerable
			@final
			@constructor
			@param {joopl.collections.Enumerable} enumerable The enumerable to manage and defer some operations
		*/
		this.declareClass("Queryable", {
			inherits: this.Enumerable,
			ctor: function(args) {
				if(typeof args != "object") {
					throw new $global.joopl.ArgumentException({
						argName: "args",
						reason: "Queryable does not have a parameterless constructor"
					});
				}

				this._.executionQueue = new collections.Queue();
				this._.enumerable = args.enumerable;
			},
			members: {
				get enumerator() { 
					return this.enumerable.enumerator;
				},
				
				get enumerable() { 
					return this._.enumerable; 
				},

				/**
					Gets execution queue. This is used by the `Queryable` in order to enqueue defered operations.

					@property executionQueue
					@private
					@readOnly
					@type joopl.collections.Queue
				*/
				get executionQueue() { 
					return this._.executionQueue; 
				},

				/**
					Executes enqueued defered operations and returns the result of chained execution

					@method executeQueue
					@private
					@return {object|null} Returns the result of executing the defered operations if the execution of the whole queue returns something
				*/
				executeQueue: function() {
					var queuedItem = null;
					var queuedMethod = null;
					var result = null;

					while(this.executionQueue.count() > 0) {
						queuedItem = this.executionQueue.dequeue();

						if(result === null) {
							queuedMethod = this.enumerable[queuedItem.method].bind(this.enumerable);
						} else {
							queuedMethod = result[queuedItem.method].bind(result);
						}

						if(queuedItem.predicateFunc instanceof Function) {
							result = queuedMethod(queuedItem.predicateFunc);
						} else {
							result = queuedMethod();
						}
					}

					return result !== null ? result : this.enumerable;
				},

				reverse: function() {
					var result = this.executeQueue();

					return result.reverse();
				},

				single: function(predicateFunc) {
					var result = this.executeQueue();

					return result.single(predicateFunc);
				},

				singleOrNull: function(predicateFunc) {
					var result = this.executeQueue();

					return result.singleOrNull(predicateFunc);
				},

				first: function(predicateFunc) {
					var result = this.executeQueue();

					return result.first(predicateFunc);
				},

				firstOrNull: function(predicateFunc) {
					var result = this.executeQueue();

					return result.firstOrNull(predicateFunc);
				},

				last: function(predicateFunc) {
					var result = this.executeQueue();

					return result.last(predicateFunc);
				},

				lastOrNull: function(predicateFunc) {
					var result = this.executeQueue();

					return result.lastOrNull(predicateFunc);
				},

				where: function(predicateFunc) {
					this.executionQueue.enqueue({
						method: "where",
						predicateFunc: predicateFunc
					});

					return this;
				},

				select: function(predicateFunc) {
					this.executionQueue.enqueue({
						method: "select",
						predicateFunc: predicateFunc
					});

					return this;
				},

				forEach: function(predicateFunc) {
					var result = this.executeQueue();

					return result.forEach(predicateFunc);
				},

				toList: function() {
					var list = new collections.List();

					if(this.executionQueue.count() == 0) {
						list.addRange(this);
					} else {
						list.addRange(this.executeQueue());
					}

					return list;
				}
			}
		});
	});
})();
/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Toolbox
 https://github.com/mfidemraizer/joopl-toolbox

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
(function() {
    "use strict";

	/*

	Queue.js

	A function to represent a queue

	Created by Stephen Morley - http://code.stephenmorley.org/ - and released under
	the terms of the CC0 1.0 Universal legal code:

	http://creativecommons.org/publicdomain/zero/1.0/legalcode

	*/

	/* Creates a new queue. A queue is a first-in-first-out (FIFO) data structure -
	 * items are added to the end of the queue and removed from the front.
	 */
	function Queue() {
		  // initialise the queue and offset
		  var queue  = [];
		  var offset = 0;

		  this.underlyingQueue = [];

		  /* Returns the length of the queue.
		   */
		  this.getLength = function(){

		    // return the length of the queue
		    return (queue.length - offset);

		  }

		  /* Returns true if the queue is empty, and false otherwise.
		   */
		  this.isEmpty = function(){

		    // return whether the queue is empty
		    return (queue.length == 0);

		  }

		  /* Enqueues the specified item. The parameter is:
		   *
		   * item - the item to enqueue
		   */
		  this.enqueue = function(item){

		    // enqueue the item
		    queue.push(item);

		  }

		  /* Dequeues an item and returns it. If the queue is empty then undefined is
		   * returned.
		   */
		  this.dequeue = function(){

		    // if the queue is empty, return undefined
		    if (queue.length == 0) return undefined;

		    // store the item at the front of the queue
		    var item = queue[offset];

		    // increment the offset and remove the free space if necessary
		    if (++ offset * 2 >= queue.length){
		      queue  = queue.slice(offset);
		      offset = 0;
		    }

		    // return the dequeued item
		    return item;

		  }

		  /* Returns the item at the front of the queue (without dequeuing it). If the
		   * queue is empty then undefined is returned.
		   */
		  this.peek = function(){

		    // return the item at the front of the queue
		    return (queue.length > 0 ? queue[offset] : undefined);

		  }
	}

	/**
		@namespace joopl.collections
	*/

	$namespace.register("joopl.collections", function() {

		/**
			Represents a FIFO (First-In, First-Out) collection of objects

			@class Queue
			@extends joopl.collections.Enumerable
			@final
		*/
		this.declareClass("Queue", {
			inherits: this.Enumerable,
			ctor: function(args) {
				this._.queue = new Queue();
			},
			members: {
				get enumerator() {
					return new $global.joopl.collections.ListEnumerator({ itemArray: this._.queue.underlyingQueue });
				},

				get queue() {
					return this._.queue;
				},

				count: function(predicateFunc) {
					if(predicateFunc instanceof Function) {
						return this.base.count(predicateFunc);
					} else {
						return this.queue.getLength();
					}
				},

				/**
					Enqueues a new item

					@method enqueue
					@param {object} item The whole item to enqueue
					@return void This method returns `void`
				*/
				enqueue: function(item) {
					this.queue.enqueue(item);
				},

				addRange: function(enumerable) {
					enumerable.forEach((function(item) {
						this._.derived.add(item);
					}).bind(this));
				},

				/**
					Dequeues an item from the queue

					@method dequeue
					@return object The dequeued item
				*/
				dequeue: function() {
					return this._.queue.dequeue();
				},

				/**
					Gets next item to dequeue without dequeueing it

					@method peek
					@return object The next item in the queue
				*/
				peek: function() {
					return this._.queue.peek();
				}
			}
		});
	});
})();
